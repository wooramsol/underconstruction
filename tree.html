<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ASCII Christmas tree</title>
    <style>
        body {
            margin: 0;
            background: #010301;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: none; 
        }
        canvas { 
            display: block;
            width: 100%;
            height: 100%;
            outline: none;
        }
    </style>
</head>
<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, treeGroup, starGroup, font, controls;

        const chars = ['R', 'A', 'M', 'S', 'O', 'L' , '*'];
        const starChars = ['*'];

        const BG_COLOR = new THREE.Color(0x010301); 
        const COLOR_BOTTOM = new THREE.Color(0x0f400f); 
        const COLOR_TOP = new THREE.Color(0xaaffaa);
        
        const STAR_COLOR_YELLOW = new THREE.Color(0xffff00);
        const STAR_COLOR_WHITE = new THREE.Color(0xffffff);

        init();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x010301, 0.035);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0.5, 14);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.max(window.devicePixelRatio, 2.0));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(BG_COLOR, 1); 
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            controls.enablePan = true;
            controls.screenSpacePanning = true;

            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.PAN,
                RIGHT: THREE.MOUSE.DOLLY
            };

            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            controls.minDistance = 5;
            controls.maxDistance = 30;

            treeGroup = new THREE.Group();
            treeGroup.position.y = 0.8; 
            scene.add(treeGroup);

            const loader = new THREE.FontLoader();
            loader.load('https://unpkg.com/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', (f) => {
                font = f;
                createExtraSpikyTree();
                createOptimizedStar();
                animate();
            });

            window.addEventListener('resize', onResize);
        }

        function createExtraSpikyTree() {
            const particleCount = 10000; 
            const treeHeight = 8.5;
            const maxRadius = 4.0; 

            for (let i = 0; i < particleCount; i++) {
                const ratio = Math.random(); 
                let heightDistribution = Math.pow(ratio, 2.0); 
                
                if (heightDistribution < 0.15 && Math.random() > heightDistribution * 4.0) {
                    continue; 
                }
                
                const y = (heightDistribution * treeHeight) - (treeHeight / 2);
                const baseConeRadius = maxRadius * (1 - heightDistribution);
                const theta = Math.random() * Math.PI * 2;

                let spikeFactor = 1.0;
                if (Math.random() > 0.7) {
                    spikeFactor = (0.9 + Math.random() * 0.2) + (Math.random() * 0.5 * (1.0 - heightDistribution));
                }

                const r = baseConeRadius * Math.sqrt(Math.random()) * spikeFactor;

                const charIndex = Math.floor(Math.random() * chars.length);
                const char = chars[charIndex];
                const baseSize = 0.11; 
                const size = baseSize + (Math.random() * 0.02); 

                const geo = new THREE.TextGeometry(char, { font: font, size: size, height: 0.01 });

                let alpha = THREE.MathUtils.smoothstep(heightDistribution, 0.0, 0.25);
                alpha = 0.1 + alpha * 0.9;

                let baseColor = COLOR_BOTTOM.clone().lerp(COLOR_TOP, heightDistribution);
                baseColor.lerp(BG_COLOR, 1.0 - alpha);

                const hsl = {};
                baseColor.getHSL(hsl);
                hsl.h += (Math.random() - 0.5) * 0.08; 
                hsl.s += (Math.random() - 0.5) * 0.5;
                hsl.l += 0.1 + (Math.random() - 0.5) * 0.6 * alpha; 
                baseColor.setHSL(hsl.h, hsl.s, hsl.l);

                const mat = new THREE.MeshBasicMaterial({ 
                    color: baseColor,
                    transparent: true,
                    opacity: alpha
                });
                const mesh = new THREE.Mesh(geo, mat);

                mesh.position.set(Math.cos(theta) * r, y, Math.sin(theta) * r);
                mesh.rotation.y = -theta; 

                treeGroup.add(mesh);
            }
        }

        function createOptimizedStar() {
            starGroup = new THREE.Group();
            const centerY = 4.8; 
            const outerRadius = 0.65; 
            const innerRadius = 0.28; 
            const thicknessFactor = 0.15;
            
            const vertices = [];
            const numPoints = 5;
            for (let i = 0; i < numPoints * 2; i++) {
                const angle = (Math.PI / 2) + (i * Math.PI / numPoints);
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                vertices.push({
                    x: Math.cos(angle) * r,
                    y: centerY + Math.sin(angle) * r
                });
            }

            const fillCount = 600; 
            let count = 0;
            let attempts = 0;
            while(count < fillCount && attempts < 10000) {
                attempts++;
                const rx = (Math.random() - 0.5) * 2 * outerRadius;
                const ry = centerY + (Math.random() - 0.5) * 2 * outerRadius;

                if (isPointInPolygon(rx, ry, vertices)) {
                    const dist = Math.sqrt(rx*rx + (ry-centerY)*(ry-centerY));
                    const distRatio = dist / outerRadius;
                    const currentMaxZ = (1.0 - distRatio) * thicknessFactor;
                    const rz = (Math.random() - 0.5) * 2 * currentMaxZ;

                    const size = 0.08 + (1.0 - distRatio) * 0.06 + Math.random() * 0.04; 
                    const char = starChars[Math.floor(Math.random() * starChars.length)];
                    
                    const pColor = (Math.random() > 0.05) ? STAR_COLOR_YELLOW.clone() : STAR_COLOR_WHITE.clone();

                    addStarChar(char, rx, ry, rz, size, pColor);
                    count++;
                }
            }
            treeGroup.add(starGroup);
        }

        function isPointInPolygon(x, y, vs) {
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i].x, yi = vs[i].y;
                const xj = vs[j].x, yj = vs[j].y;
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function addStarChar(char, x, y, z, size, color) {
            const geo = new THREE.TextGeometry(char, { font: font, size: size, height: 0.02 });
            geo.center();
            const mat = new THREE.MeshBasicMaterial({ color: color.clone() });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            
            mesh.userData.hsl = {};
            color.getHSL(mesh.userData.hsl);
            
            starGroup.add(mesh);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            treeGroup.rotation.y += 0.008; 
            
            if (starGroup) {
                starGroup.rotation.y -= 0.016;

                const time = Date.now() * 0.004; 
                
                starGroup.children.forEach((mesh, index) => {
                    if (mesh.userData.hsl) {
                        const offset = index * 0.5; 
                        const wave = Math.sin(time * 0.7 + offset); 
                        const flash = Math.pow(Math.abs(wave), 5); 
                        
                        const lightness = flash * 3.0;
                        
                        mesh.material.color.setHSL(
                            mesh.userData.hsl.h,
                            mesh.userData.hsl.s,
                            Math.min(1.0, lightness) 
                        );
                    }
                });
            }
            
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.max(window.devicePixelRatio, 2.0));
        }
    </script>
</body>
</html>